{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"about_the_author/","title":"About the Author","text":"<p>Richard Chou is a Lead Developer at Ezy Raise, where he assists fundraisers in running successful online fundraising events. He has extensive experience in Ruby/Rails, and he is also a certified professional in AWS.</p> <p> </p>"},{"location":"caddy_cluster/","title":"Upgrading to Caddy Cluster","text":"<p>In previous chapter, we provisioned just a single Caddy instance, and the TLS certificate is stored on the instance. In this chapter we will build a Caddy cluster so each Caddy instance is load-balanced. We will also build a Redis server, TLS certificates will be stored on Redis and can be retrieved by Caddy cluster.</p> <p>manifest.yml<pre><code># The manifest for the \"caddy-webserver\" service.\n# Read the full specification for the \"Load Balanced Web Service\" type at:\n#  https://aws.github.io/copilot-cli/docs/manifest/lb-web-service/\n# Your service name will be used in naming your resources like log groups, ECS services, etc.\nname: nlb\ntype: Load Balanced Web Service\n# Distribute traffic to your service.\n# Configuration for your containers and service.\nimage:\n# Docker build arguments. For additional overrides: https://aws.github.io/copilot-cli/docs/manifest/lb-web-service/#image-build\nbuild: Dockerfile\n# Port exposed through your container to route traffic to it.\nport: 443\nhttp: false\nnlb:\nport: 443/tcp\nadditional_listeners:  - port: 80/tcp  cpu: 256       # Number of CPU units for the task.\nmemory: 512    # Amount of memory in MiB used by the task.\nplatform: linux/x86_64  # See https://aws.github.io/copilot-cli/docs/manifest/lb-web-service/#platform\ncount: 3       # Number of tasks that should be running in your service.\nexec: true     # Enable running commands in your container.\nnetwork:\nconnect: true # Enable Service Connect for intra-environment traffic between services.\n</code></pre> line 28: change task count from 1 to 3.</p>"},{"location":"caddy_cluster/#adding-a-redis-server","title":"Adding a Redis server","text":"copilot/caddy/addons/template.yml<pre><code>Parameters:\nApp:\nType: String\nDescription: Your application's name.\nEnv:\nType: String\nDescription: The environment name your service, job, or workflow is being deployed to.\nName:\nType: String\nDescription: The name of the service, job, or workflow being deployed.\nResources:\n# Subnet group to control where the Redis gets placed\nRedisSubnetGroup:\nType: AWS::ElastiCache::SubnetGroup\nProperties:\nDescription: Group of subnets to place Redis into\nSubnetIds: !Split [ ',', { 'Fn::ImportValue': !Sub '${App}-${Env}-PrivateSubnets' } ]\n# Security group to add the Redis cluster to the VPC,\n# and to allow the Fargate containers to talk to Redis on port 6379\nRedisSecurityGroup:\nType: AWS::EC2::SecurityGroup\nProperties:\nGroupDescription: \"Redis Security Group\"\nVpcId: { 'Fn::ImportValue': !Sub '${App}-${Env}-VpcId' }\n# Enable ingress from other ECS services created within the environment.\nRedisIngress:\nType: AWS::EC2::SecurityGroupIngress\nProperties:\nDescription: Ingress from Fargate containers\nGroupId: !Ref 'RedisSecurityGroup'\nIpProtocol: tcp\nFromPort: 6379\nToPort: 6379\nSourceSecurityGroupId: { 'Fn::ImportValue': !Sub '${App}-${Env}-EnvironmentSecurityGroup' }\n# The cluster itself.\nRedis:\nType: AWS::ElastiCache::CacheCluster\nProperties:\nEngine: redis\nCacheNodeType: cache.t2.micro\nNumCacheNodes: 1\nCacheSubnetGroupName: !Ref 'RedisSubnetGroup'\nVpcSecurityGroupIds:\n- !GetAtt 'RedisSecurityGroup.GroupId'\n# Redis endpoint stored in SSM so that other services can retrieve the endpoint.\nRedisEndpointAddressParam:\nType: AWS::SSM::Parameter\nProperties:\nName: !Sub '/${App}/${Env}/${Name}/redis'   # Other services can retrieve the endpoint from this path.\nType: String\nValue: !GetAtt 'Redis.RedisEndpoint.Address'\nOutputs:\nRedisEndpoint:\nDescription: The endpoint of the redis cluster\nValue: !GetAtt 'Redis.RedisEndpoint.Address'\nExport:\nName: RedisEndpoint\n</code></pre>"},{"location":"caddy_cluster/#adding-environment-variables-to-network-load-balancer-manifest","title":"Adding environment variables to Network Load Balancer Manifest","text":"copilot/nlb/manifest.yml<pre><code>variables:\nCADDY_CLUSTERING_REDIS_HOST:\nfrom_cfn: RedisEndpoint\nCADDY_CLUSTERING_REDIS_TLS: false\nCADDY_CLUSTERING_REDIS_TLS_INSECURE: true\n</code></pre>"},{"location":"caddy_cluster/#updating-caddyfile-to-store-tls-certs-in-redis","title":"Updating Caddyfile to store TLS certs in Redis","text":"<pre><code>{\n    debug\n    on_demand_tls {\n        ask https://portfolio-starter-kit-beta-six.vercel.app/api/tls_authoriser\n\n        burst 5\n        interval 2m\n    }\n\n    storage redis {\n        host {$CADDY_CLUSTERING_REDIS_HOST}\n        tls_enabled {$CADDY_CLUSTERING_REDIS_TLS}\n        tls_insecure {$CADDY_CLUSTERING_REDIS_TLS_INSECURE}\n    }\n}\n\nhttps:// {\n    tls {\n        on_demand\n    }\n\n    reverse_proxy https://portfolio-starter-kit-beta-six.vercel.app {\n        header_down Strict-Transport-Security max-age=31536000\n        header_up X-Real-IP {remote}\n        header_up Host {upstream_hostport}\n    }\n}\n</code></pre>"},{"location":"dns/","title":"Adding a CNAME record to Client's DNS","text":"<p>After Network Load Balancer is provisioned, it will have a domain name, for example <pre><code>caddy-Publi-JRJUD8MD0RLE-671e55804baa69eb.elb.us-west-2.amazonaws.com\n</code></pre> You only need to give this domain name to your client, and he/she will create a CNAME record in their DNS. For example:</p> <p></p> <p>And your client's domain (c21.awscustomdomainmanager.xyz) will have access to your service.</p>"},{"location":"network_load_balancer_and_caddy/","title":"Provisioning AWS Network Load Balancer and Single Caddy instance","text":"<p>We will use AWS Copilot to build a Network Load Balancer. It cannot be Application Load Balancer or Classic Load Balancer because we need the encrypted traffic to flow through the load balancer to Caddy instance. And then Caddy will be able to do its work.</p> <p>Here's the manifest for building Network Load Balancer using AWS Copilot:</p> copilot/nlb/manifest.yml<pre><code># The manifest for the \"caddy-webserver\" service.\n# Read the full specification for the \"Load Balanced Web Service\" type at:\n#  https://aws.github.io/copilot-cli/docs/manifest/lb-web-service/\n# Your service name will be used in naming your resources like log groups, ECS services, etc.\nname: nlb\ntype: Load Balanced Web Service\n# Distribute traffic to your service.\n# Configuration for your containers and service.\nimage:\n# Docker build arguments. For additional overrides: https://aws.github.io/copilot-cli/docs/manifest/lb-web-service/#image-build\nbuild: Dockerfile\n# Port exposed through your container to route traffic to it.\nport: 443\nhttp: false\nnlb:\nport: 443/tcp\nadditional_listeners:  - port: 80/tcp  cpu: 256       # Number of CPU units for the task.\nmemory: 512    # Amount of memory in MiB used by the task.\nplatform: linux/x86_64  # See https://aws.github.io/copilot-cli/docs/manifest/lb-web-service/#platform\ncount: 1       # Number of tasks that should be running in your service.\nexec: true     # Enable running commands in your container.\nnetwork:\nconnect: true # Enable Service Connect for intra-environment traffic between services.\n</code></pre>"},{"location":"network_load_balancer_and_caddy/#dockerfile","title":"Dockerfile","text":"Dockerfile<pre><code>FROM amazonlinux:2\nARG CADDY_VERSION=v2.6.4\nARG OS=linux\n\n# Install dependencies\nRUN yum update -y &amp;&amp; \\\nyum install golang -y\n\nRUN GOBIN=/usr/local/bin/ go install github.com/caddyserver/xcaddy/cmd/xcaddy@latest\n\nRUN mkdir -p /caddy-build &amp;&amp; \\\nGOOS=${OS} xcaddy build ${CADDY_VERSION} --with github.com/gamalan/caddy-tlsredis --output /caddy-build/caddy\n\nCOPY Caddyfile /etc/caddy/Caddyfile\n\nEXPOSE 80\nEXPOSE 443\nCMD [\"/caddy-build/caddy\", \"run\", \"--config\", \"/etc/caddy/Caddyfile\", \"--adapter\", \"caddyfile\"]\n</code></pre> <p>Line 12, 13: Building caddy with Redis. So certs can be stored in Redis, and retrieved by Caddy instance.</p>"},{"location":"network_load_balancer_and_caddy/#caddyfile","title":"Caddyfile","text":"<p>Caddyfile is Caddy's config file. Caddyfile<pre><code>{\n    debug\n    on_demand_tls {\n        ask https://portfolio-starter-kit-beta-six.vercel.app/api/tls_authoriser\n\n        burst 5\n        interval 2m\n    }\n}\n\nhttps:// {\n    tls {\n        on_demand\n    }\n\n    reverse_proxy https://portfolio-starter-kit-beta-six.vercel.app {\n        header_down Strict-Transport-Security max-age=31536000\n        header_up X-Real-IP {remote}\n        header_up Host {upstream_hostport}\n    }\n}\n</code></pre> Line 4: Caddy will ask the specified endpoint for authorisation, i.e. can Caddy fetch and install a cert for a custom domain? The endpoint must return 200 for allow, and any other statuses (eg 403) for deny. The endpoint, in this case, is a webserver, it can be of other forms like Lambda, as long as it returns 200.</p> <p>Example of an endpoint: /pages/api/tls_authoriser.js<pre><code>export default function handler(req, res) {\nres.setHeader('Cache-Control', 'no-store, max-age=0')\nres.status(200).json({})\n}\n</code></pre> Line 12-14: Cernts are fetched and installed on demand.</p> <p>Line 16-20: Once a cert is fetched and installed, proxy traffic to original domain.</p>"}]}